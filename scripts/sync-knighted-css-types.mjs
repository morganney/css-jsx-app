#!/usr/bin/env node
import { promises as fs } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')
const declarationsDir = path.join(projectRoot, '.knighted-css')
const outputFile = path.join(projectRoot, 'src/types/knighted-css-registry.d.ts')

const header = `// Generated by scripts/sync-knighted-css-types.mjs\n// Do not edit manually.\n\n`

async function readGeneratedEntries() {
  try {
    const files = await fs.readdir(declarationsDir)
    const entries = []

    for (const file of files.sort()) {
      if (!file.endsWith('.d.ts')) continue
      const fullPath = path.join(declarationsDir, file)
      const content = await fs.readFile(fullPath, 'utf8')
      const moduleMatch = content.match(/declare module\s+["']([^"']+)["']/)
      if (!moduleMatch) continue

      const stableIndex = content.indexOf('export const stableSelectors:')
      if (stableIndex === -1) continue
      const afterExport = content.slice(stableIndex)
      const readonlyIndex = afterExport.indexOf('Readonly<')
      if (readonlyIndex === -1) continue

      const afterReadonly = afterExport.slice(readonlyIndex + 'Readonly<'.length)
      let depth = 0
      let endOffset = -1
      for (let i = 0; i < afterReadonly.length; i += 1) {
        const char = afterReadonly[i]
        if (char === '{') {
          depth += 1
        } else if (char === '}') {
          depth -= 1
          if (depth === 0) {
            endOffset = i
            break
          }
        }
      }

      if (endOffset === -1) continue
      const inner = afterReadonly.slice(0, endOffset + 1)
      const typeText = `Readonly<${inner}>`
      entries.push({ moduleId: moduleMatch[1], typeText })
    }

    return entries
  } catch (error) {
    if (error && error.code === 'ENOENT') {
      return []
    }

    throw error
  }
}

function buildRegistrySource(entries) {
  const lines = [
    header,
    'declare global {',
    '  interface KnightedCssGeneratedSelectors {',
  ]

  if (entries.length === 0) {
    lines.push('    // No stable selector declarations were found.')
  } else {
    for (const entry of entries) {
      const formattedType = entry.typeText.replace(/\n/g, '\n    ')
      lines.push(`    '${entry.moduleId}': ${formattedType}`)
    }
  }

  lines.push(
    '  }',
    '}',
    '',
    'export type KnightedCssModuleId = keyof KnightedCssGeneratedSelectors',
  )
  lines.push(
    'export type KnightedCssSelectorFor<Module extends KnightedCssModuleId> =',
    '  KnightedCssGeneratedSelectors[Module]',
    '',
    'export {}',
    '',
  )

  return lines.join('\n')
}

async function main() {
  const entries = await readGeneratedEntries()
  const source = buildRegistrySource(entries)
  await fs.mkdir(path.dirname(outputFile), { recursive: true })
  await fs.writeFile(outputFile, source)
}

main().catch(error => {
  console.error('[knighted-css] Failed to sync selector registry:', error)
  process.exitCode = 1
})
